<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Air Canvas</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link href="./index.css" rel="stylesheet">
</head>

<body>
    <div class="container">
        <video class="input_video"></video>
        <div class="on-screen" style="display:flex;">
            <canvas class="output_canvas" width="750px" height="500px"></canvas>
            <canvas class="paint_canvas" width="750px" height="500px"></canvas>
        </div>
        <div class="info" style="position: absolute; top: 500px;">
            <h2 class="distance">
                Keep your hand 40 to 50 cm away from the camera for sign detections.
            </h2>
            <div class="color-choice" style="display: flex;">
                <h2>pick a color:</h2>
                <input id="color-choice" type="color" value="#000000">
            </div>
            <h3 class="signs">
                Drawing => Index Finger ; Erasing => Index + Middle Finger
            </h3>
            <h2 class="position"></h2>
        </div>
    </div>
    <script type="module">
        var prev_x = undefined;
        var prev_y = undefined;

        //info variables
        const positionElement = document.getElementsByClassName('position')[0];

        //feed and drawing
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');
        const paintElement = document.getElementsByClassName('paint_canvas')[0];
        const paintCtx = paintElement.getContext('2d');


        function onResults(results) {
            let color = document.getElementById("color-choice").value;
            canvasCtx.drawImage(
                results.image, 0, 0, canvasElement.width, canvasElement.height);
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {

                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,
                        { color: '#00FF00', lineWidth: 5 });
                    drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });

                    const x1 = results.multiHandLandmarks[0][8].x;
                    const y1 = results.multiHandLandmarks[0][8].y;
                    const x2 = results.multiHandLandmarks[0][4].x;
                    const y2 = results.multiHandLandmarks[0][4].y;
                    const x3 = results.multiHandLandmarks[0][12].x;
                    const y3 = results.multiHandLandmarks[0][12].y;
                    const distance1 = Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2));
                    const distance2 = Math.sqrt(Math.pow((x3 - x2), 2) + Math.pow((y3 - y2), 2));
                    const distance3 = Math.sqrt(Math.pow((x3 - x1), 2) + Math.pow((y3 - y1), 2));
                    if ((distance1 >= 0.1) && (distance2 <= 0.2)) {
                        positionElement.innerText = "DRAWING POSITION";
                        if(prev_x && prev_y){
                            paintCtx.lineWidth = 5;
                            paintCtx.beginPath();
                            paintCtx.strokeStyle = `${color}`;
                            paintCtx.fillStyle = `${color}`;
                            paintCtx.moveTo(prev_x, prev_y);
                            paintCtx.lineTo(x1 * canvasElement.width,  y1 * canvasElement.height);
                            paintCtx.stroke();
                            paintCtx.closePath();
                            prev_x = x1 * canvasElement.width;
                            prev_y = y1 * canvasElement.height;
                        }
                        else{
                            paintCtx.beginPath();
                            paintCtx.arc(x1 * canvasElement.width, y1 * canvasElement.height, 5, 0, 2 * Math.PI);
                            paintCtx.fillStyle = `${color}`;
                            paintCtx.fill();
                            paintCtx.save();
                            prev_x = x1 * canvasElement.width;
                            prev_y = y1 * canvasElement.height;
                        }
                    }
                    else if ((distance1 >= 0.1) && (distance2 >= 0.1) && (distance2 <= 0.4)) {
                        positionElement.innerText = "ERASING POSITION";
                        // paintCtx.clearRect(0,0,canvasElement.width,canvasElement.height);
                        prev_x = undefined;
                        prev_y = undefined;
                        canvasCtx.fillStyle = "rgba(255, 255, 255,  0.6)";
                        canvasCtx.fillRect(x3 * canvasElement.width, y3 * canvasElement.height,50,50);
                        paintCtx.clearRect(x3 * canvasElement.width, y3 * canvasElement.height,50,50);
                        continue;
                    }
                    else {
                        positionElement.innerText = "DEFAULT POSITION";
                        prev_x = undefined;
                        prev_y = undefined;
                    }
                }
            }
        }

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 750,
            height: 350
        });
        camera.start();
    </script>
</body>

</html>